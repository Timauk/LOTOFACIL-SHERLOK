<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sherlock das Bolinhas 4.0</title>
    <style>
        .progress-container {
            width: 100%;
            background-color: #f3f3f3;
            border: 1px solid #ccc;
            height: 20px;
            margin: 10px 0;
        }
        .progress-bar {
            height: 100%;
            width: 0;
            background-color: #4caf50;
            text-align: center;
            color: white;
            line-height: 20px;
            transition: width 0.3s;
        }
        input[type="text"], input[type="file"] {
            width: 50%;
            padding: 5px;
            margin: 10px 0;
        }
        button {
            padding: 10px;
            margin-top: 10px;
        }
        .btn-sherlock {
            background-color: red;
            color: white;
            padding: 10px;
        }
    </style>
</head>
<body>
    <h1>Sherlock das Bolinhas 4.0</h1>

    <!-- Upload de Dados -->
    <h2>Faça upload dos dados (CSV):</h2>
    <input type="file" id="fileInput" />
    <button onclick="carregarDados()">Carregar Dados</button>
    <p id="statusUpload"></p>

    <!-- Treinamento do Modelo -->
    <h2>Treinar/Atualizar Modelo:</h2>
    <button onclick="treinarModelo()">Treinar/Atualizar Modelo</button>

    <!-- Barra de progresso para treinamento -->
    <div class="progress-container">
        <div class="progress-bar" id="progressBar">0%</div>
    </div>
    <p id="statusTreinamento"></p>

    <!-- Ciclo de Previsões do Sherlock -->
    <h2>Ciclo de Previsões Sherlock (50 palpites):</h2>
    <button onclick="iniciarCiclo()">Iniciar Ciclo de Previsões</button>

    <div class="progress-container">
        <div class="progress-bar" id="progressBarCiclo">0%</div>
    </div>
    <p id="statusCiclo"></p>

    <!-- Botão para salvar o modelo -->
    <h2>Salvar o Modelo Treinado</h2>
    <button onclick="salvarModelo()">Salvar Modelo</button>

    <!-- Resultados dos Palpites -->
    <h3>Resultados dos Palpites:</h3>
    <div id="resultadosCiclo"></div>
    
    <!--GRAFICO QUE VISUALIZA EM TEMPO REAL O TREINAMENTO -->
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-vis"></script>
    <!-- TensorFlow JS -->
   

    <script>
       let dados = [];
        let model; 
        let treinando = false;
        let cicloRodando = false;
        const numCiclos = 50;
        let palpites = [];

        function carregarDados() {
            const input = document.getElementById('fileInput').files[0];
            if (!input) {
                alert("Por favor, selecione um arquivo CSV.");
                return;
            }
            const reader = new FileReader();
            reader.onload = function (event) {
                const text = event.target.result;
                processarCSV(text);
                document.getElementById("statusUpload").innerText = "Dados carregados com sucesso!";
            };
            reader.readAsText(input);
        }

        function processarCSV(text) {
            const linhas = text.trim().split("\n").slice(1); // Ignorar cabeçalho
            dados = [];

            // Preparando variáveis para normalizar dados
            let concursoMin = Infinity;
            let concursoMax = -Infinity;
            let dataMin = Infinity;
            let dataMax = -Infinity;

            // Primeira passada para calcular os limites de normalização (Min-Max)
            linhas.forEach(linha => {
                const valores = linha.split(",");

                // Número do concurso
                const concurso = Number(valores[0]);

                // Data do sorteio
                const dataSorteio = new Date(valores[1].split("/").reverse().join("-")).getTime();

                // Atualizar limites
                if (concurso < concursoMin) concursoMin = concurso;
                if (concurso > concursoMax) concursoMax = concurso;
                if (dataSorteio < dataMin) dataMin = dataSorteio;
                if (dataSorteio > dataMax) dataMax = dataSorteio;
            });

            // Segunda passada para normalizar os dados
            linhas.forEach((linha) => {
                const valores = linha.split(",");

                const concurso = Number(valores[0]);
                const dataSorteio = new Date(valores[1].split("/").reverse().join("-")).getTime();
                const bolas = valores.slice(2, 17).map(Number);

                if (bolas.length === 15 && bolas.every(num => !isNaN(num))) {
                    // Normalizar o concurso e a data usando Min-Max
                    const concursoNormalizado = (concurso - concursoMin) / (concursoMax - concursoMin);
                    const dataNormalizada = (dataSorteio - dataMin) / (dataMax - dataMin);

                    // Adicionar os dados normalizados ao array
                    dados.push({ concurso: concursoNormalizado, dataSorteio: dataNormalizada, bolas });
                }
            });

            if (dados.length === 0) {
                alert("Nenhum dado válido encontrado!");
            }
        }

       // Função para normalizar os dados
function normalizarDados(dados) {
    // Pega o número máximo de concurso
    const maxConcurso = Math.max(...dados.map(d => d.concurso));

    // Normaliza o número do concurso e a data
    return dados.map(d => {
        // Normalizando o número do concurso
        const concursoNormalizado = d.concurso / maxConcurso;

        // Normalizando a data como timestamp (entre 0 e 1)
        const timestamp = new Date(d.dataSorteio.split('/').reverse().join('-')).getTime();
        const minDate = new Date(dados[0].dataSorteio.split('/').reverse().join('-')).getTime();
        const maxDate = new Date(dados[dados.length - 1].dataSorteio.split('/').reverse().join('-')).getTime();
        const dataNormalizada = (timestamp - minDate) / (maxDate - minDate);

        // Retorna o objeto com os valores normalizados
        return {
            ...d,
            concurso: concursoNormalizado,
            dataSorteio: dataNormalizada,
            bolas: d.bolas.map(bola => bola / 25) // Normalizando bolas (entre 0 e 1)
        };
    });
}
async function iniciarCiclo() {
    if (cicloRodando) {
        alert("Ciclo já está rodando.");
        return;
    }
    cicloRodando = true;

    document.getElementById('progressBarCiclo').style.width = '0%';
    document.getElementById('progressBarCiclo').innerText = '0%';
    document.getElementById('statusCiclo').innerText = 'Ciclo iniciado. Gerando palpites...';

    for (let cicloAtual = 0; cicloAtual < numCiclos; cicloAtual++) {
        const concursoAtual = dados[dados.length - 1];
        gerarPalpitesComConcurso(concursoAtual);

        const progressoCiclo = Math.floor((cicloAtual / numCiclos) * 100);
        document.getElementById('progressBarCiclo').style.width = progressoCiclo + '%';
        document.getElementById('progressBarCiclo').innerText = progressoCiclo + '%';
        document.getElementById('statusCiclo').innerText = `Ciclo ${cicloAtual + 1} concluído`;

        await new Promise(resolve => setTimeout(resolve, 500)); // Pausa para não travar o navegador
    }

    exibirResultados();
    cicloRodando = false;
    document.getElementById('statusCiclo').innerText = "Ciclo de previsões concluído!";
}
async function treinarModelo() {
    if (dados.length === 0) {
        alert("Carregue os dados primeiro!");
        return;
    }
    if (treinando) {
        alert("O modelo já está sendo treinado.");
        return;
    }
    treinando = true;
    await criarModelo();

    // Normalizando os dados
    const dadosNormalizados = normalizarDados(dados);

    // Preparar séries temporais com os dados normalizados e uma janela de 10 concursos
    const { sequencias, labels } = prepararSeriesTemporais(dadosNormalizados, 10);

    // Criando tensores para treinamento
    const xs = tf.tensor3d(sequencias);
    const ys = tf.tensor2d(labels);

    const numEpocas = 100;

    // Variável para armazenar o histórico de perdas
    const lossValues = [];

    // Realiza o treinamento e exibe os gráficos de perda e visualização dos pesos
    await model.fit(xs, ys, {
        epochs: numEpocas,
        callbacks: {
            onEpochEnd: (epoch, logs) => {
                console.log(`Epoch ${epoch}: loss = ${logs.loss}`);
                document.getElementById('statusTreinamento').innerText = `Época ${epoch + 1} concluída. Erro: ${logs.loss.toFixed(6)}`;

                const progresso = Math.floor(((epoch + 1) / numEpocas) * 100);
                document.getElementById('progressBar').style.width = progresso + '%';
                document.getElementById('progressBar').innerText = progresso + '%';

                // Salva o valor da perda para exibir no gráfico
                lossValues.push({ epoch: epoch + 1, loss: logs.loss });

                const surface = { name: 'Loss History', tab: 'Treinamento' };
                tfvis.render.linechart(surface, { values: lossValues, series: ['Loss'] }, {
                    xLabel: 'Epoch',
                    yLabel: 'Loss',
                    width: 400,
                    height: 300
                });

                const weightsSurface = { name: `Pesos - Epoch ${epoch + 1}`, tab: 'Pesos' };
                tfvis.show.layer(weightsSurface, model.getLayer(undefined, 0));
            }
        }
    });

    treinando = false;
    alert("Treinamento concluído!");
}

// Função para preparar séries temporais
function prepararSeriesTemporais(dados, janela) {
    let sequencias = [];
    let labels = [];

    for (let i = 0; i < dados.length - janela; i++) {
        let sequencia = dados.slice(i, i + janela); // Pega uma janela de concursos
        let label = dados[i + janela].bolas; // O alvo é o próximo conjunto de bolas sorteadas

        // Inclui as bolas, o número do concurso e a data sorteio normalizados
        sequencias.push(sequencia.map(d => [...d.bolas, d.concurso, d.dataSorteio]));
        labels.push(label);
    }

    return { sequencias, labels };
}

// Função para criar o modelo
async function criarModelo() {
    if (!model) {
        model = tf.sequential();
        
        // Primeira camada LSTM para capturar padrões temporais
        model.add(tf.layers.lstm({
            units: 64, 
            inputShape: [10, 17],  // Ajustado para 10 concursos e 17 características
            returnSequences: false
        }));

        // Camadas densas para processamento mais profundo
        model.add(tf.layers.dense({ units: 256, activation: 'relu' }));
        model.add(tf.layers.dense({ units: 128, activation: 'relu' }));
        model.add(tf.layers.dense({ units: 64, activation: 'relu' }));

        // Camada de saída para prever as 15 bolas sorteadas
        model.add(tf.layers.dense({ units: 15, activation: 'sigmoid' }));

        // Compilar o modelo com otimizador e função de perda
        model.compile({ optimizer: 'adam', loss: 'meanSquaredError' });

        // Exibe as camadas do modelo e seus detalhes
        const layerSurface = { name: 'Arquitetura do Modelo', tab: 'Modelo' };
        tfvis.show.modelSummary(layerSurface, model);
    }
}

async function treinarModelo() {
    if (dados.length === 0) {
        alert("Carregue os dados primeiro!");
        return;
    }
    if (treinando) {
        alert("O modelo já está sendo treinado.");
        return;
    }
    treinando = true;
    await criarModelo();

    // Normalizando os dados
    const dadosNormalizados = normalizarDados(dados);

    // Preparar séries temporais com os dados normalizados e uma janela de 10 concursos
    const { sequencias, labels } = prepararSeriesTemporais(dadosNormalizados, 10);

    // Criando tensores para treinamento
    const xs = tf.tensor3d(sequencias);
    const ys = tf.tensor2d(labels);

    const numEpocas = 100;

    // Container para os gráficos de perda e camadas
    const surface = { name: 'Gráficos de Treinamento', tab: 'Treinamento' };

    // Variável para armazenar o histórico de perdas
    const lossValues = [];

    // Realiza o treinamento e exibe os gráficos de perda e visualização dos pesos
    await model.fit(xs, ys, {
        epochs: numEpocas,
        callbacks: {
            onEpochEnd: (epoch, logs) => {
                // Exibe o erro da época atual no console e na interface
                console.log(`Epoch ${epoch}: loss = ${logs.loss}`);
                document.getElementById('statusTreinamento').innerText = `Época ${epoch + 1} concluída. Erro: ${logs.loss.toFixed(6)}`;

                // Atualiza a barra de progresso
                const progresso = Math.floor(((epoch + 1) / numEpocas) * 100);
                document.getElementById('progressBar').style.width = progresso + '%';
                document.getElementById('progressBar').innerText = progresso + '%';

                // Salva o valor da perda para exibir no gráfico
                lossValues.push({ epoch: epoch + 1, loss: logs.loss });

                // Exibe o gráfico de perda
                const surface = { name: 'Loss History', tab: 'Treinamento' }; 
                tfvis.render.linechart(surface, { values: lossValues, series: ['Loss'] }, {
                    xLabel: 'Epoch',
                    yLabel: 'Loss',
                    width: 400,
                    height: 300
                });

                // Visualizar os pesos da primeira camada após cada época
                const weightsSurface = { name: `Pesos - Epoch ${epoch + 1}`, tab: 'Pesos' };
                tfvis.show.layer(weightsSurface, model.getLayer(undefined, 0));  // Mostra a primeira camada (LSTM)
            }
        }
    });

    treinando = false;
    alert("Treinamento concluído!");
}




        function gerarPalpitesComConcurso(concursoAtual) {
            const numPalpites = 50;
            palpites = [];
            const penultimoConcurso = dados[dados.length - 2].bolas;

            for (let i = 0; i < numPalpites; i++) {
                const input = tf.tensor2d([penultimoConcurso.map(bola => bola / 25)]);
                const predicao = model.predict(input).dataSync();
                const bolasPrevistas = Array.from(predicao).map(p => Math.round(p * 25)).slice(0, 15);
                palpites.push(bolasPrevistas);
            }
        }

        async function iniciarCiclo() {
            if (cicloRodando) {
                alert("Ciclo já está rodando.");
                return;
            }
            cicloRodando = true;

            document.getElementById('progressBarCiclo').style.width = '0%';
            document.getElementById('progressBarCiclo').innerText = '0%';
            document.getElementById('statusCiclo').innerText = 'Ciclo iniciado. Gerando palpites...';

            for (let cicloAtual = 0; cicloAtual < numCiclos; cicloAtual++) {
                const concursoAtual = dados[dados.length - 1];
                gerarPalpitesComConcurso(concursoAtual);

                const progressoCiclo = Math.floor((cicloAtual / numCiclos) * 100);
                document.getElementById('progressBarCiclo').style.width = progressoCiclo + '%';
                document.getElementById('progressBarCiclo').innerText = progressoCiclo + '%';
                document.getElementById('statusCiclo').innerText = `Ciclo ${cicloAtual + 1} concluído`;

                await new Promise(resolve => setTimeout(resolve, 500)); // Pausa para não travar o navegador
            }

            exibirResultados();
            cicloRodando = false;
            document.getElementById('statusCiclo').innerText = "Ciclo de previsões concluído!";
        }

        function exibirResultados() {
            const resultadosDiv = document.getElementById('resultadosCiclo');
            resultadosDiv.innerHTML = ""; // Limpar resultados anteriores
            palpites.forEach((palpite, index) => {
                const palpiteText = `Palpite ${index + 1}: ${palpite.join(", ")}`;
                const pElement = document.createElement('p');
                pElement.innerText = palpiteText;
                resultadosDiv.appendChild(pElement);
            });
        }

        // Função para salvar o modelo treinado
        async function salvarModelo() {
            const saveResult = await model.save('downloads://modelo-sherlock');
            console.log("Modelo salvo com sucesso:", saveResult);
        }
    </script>

</body>
</html>
