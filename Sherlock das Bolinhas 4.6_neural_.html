
<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Jogo do Sherlock 4.6 neural</title>
    <style>
        .progress-container {
            width: 100%;
            background-color: #f3f3f3;
            border: 1px solid #ccc;
            height: 20px;
            margin: 10px 0;
        }
        .progress-bar {
            height: 100%;
            width: 0;
            background-color: #4caf50;
            text-align: center;
            color: white;
            line-height: 20px;
            transition: width 0.3s;
        }
        input[type="text"], input[type="file"] {
            width: 50%;
            padding: 5px;
            margin: 10px 0;
        }
        button {
            padding: 10px;
            margin-top: 10px;
        }
        .btn-sherlock {
            background-color: red;
            color: white;
            padding: 10px;
        }
        .scoreboard {
            margin-top: 20px;
            border: 1px solid #000;
            padding: 10px;
        }
    </style>
</head>
<body>
    <h1>Jogo do Sherlock 4.6</h1>

    <!-- Upload de Dados -->
    <h2>Faça upload dos dados (CSV):</h2>
    <input type="file" id="fileInput" />
    <button onclick="carregarDados()">Carregar Dados</button>
    <p id="statusUpload"></p>

    <!-- Treinamento do Modelo -->
    <h2>Treinar/Atualizar Modelo:</h2>
    <button onclick="treinarModelo()">Treinar/Atualizar Modelo</button>

    <!-- Barra de progresso para treinamento -->
    <div class="progress-container">
        <div class="progress-bar" id="progressBar">0%</div>
    </div>
    <p id="statusTreinamento"></p>

    <!-- Botão para carregar o modelo salvo -->
    <h2>Carregar Modelo Salvo</h2>
    <input type="file" id="modelJson" accept=".json"/>
    <input type="file" id="modelWeights" accept=".bin"/>
    <button onclick="carregarModelo()">Carregar Modelo</button>

    <!-- Botão para jogar com o modelo carregado -->
    <h2>Jogar com Sherlock</h2>
    <button onclick="jogarComModelo()">Jogar</button>

    <!-- Ciclo de Previsões do Sherlock -->
    <h2>Ciclo de Previsões Sherlock (50 palpites):</h2>
    <button onclick="iniciarCiclo()">Iniciar Ciclo de Previsões</button>

    <!-- Checkbox para Jogo Infinito -->
    <label>
        <input type="checkbox" id="jogoInfinitoCheckbox"> Jogo Infinito
    </label>

    <!-- Exibir o gráfico de desempenho -->
    <div id="graficoDesempenho"></div>

    <!-- Placar das Gerações -->
    <div class="scoreboard" id="scoreboard">
        <h3>Placar das Gerações</h3>
        <ul id="geracoesRanking"></ul>
    </div>

    <!-- TensorFlow JS -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-vis"></script>

    <script>
        let dados = [];
        let model; 
        let treinando = false;
        let cicloRodando = false;
        const numCiclos = 50;
        let palpites = [];
        let jogoInfinito = false;
        let campeoes = [];
        let geracaoAtual = 1;
        let pontosGeracoes = [];
        let scene, camera, renderer, sphere;

        //Função para configurar a cena em Three.js
function initThreeJS() {
    scene = new THREE.Scene();
    camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.z = 5;

    renderer = new THREE.WebGLRenderer();
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    const geometry = new THREE.SphereGeometry(1, 32, 32);
    const material = new THREE.MeshBasicMaterial({ color: 0x00ff00 });
    sphere = new THREE.Mesh(geometry, material);
    scene.add(sphere);

    animate();
}

function animate() {
    requestAnimationFrame(animate);
    sphere.rotation.x += 0.01;
    sphere.rotation.y += 0.01;
    renderer.render(scene, camera);
}

initThreeJS();


    // Listener para o checkbox de Jogo Infinito
    document.getElementById('jogoInfinitoCheckbox').addEventListener('change', function(event) {
            jogoInfinito = event.target.checked;
        });

    // Função para carregar dados do CSV
    function carregarDados() {
            const input = document.getElementById('fileInput').files[0];
            if (!input) {
                alert("Por favor, selecione um arquivo CSV.");
                return;
            }
            const reader = new FileReader();
            reader.onload = function (event) {
                const text = event.target.result;
                processarCSV(text);
                document.getElementById("statusUpload").innerText = "Dados carregados com sucesso!";
            };
            reader.readAsText(input);
        }

        // Função para processar e normalizar os dados, incluindo data e número de concursos
function processarCSV(text) {
    const linhas = text.trim().split("\n").slice(1); // Ignorar cabeçalho
    dados = [];
        // Função para processar e normalizar os dados, incluindo data e número de concursos
function processarCSV(text) {
    const linhas = text.trim().split("\n").slice(1); // Ignorar cabeçalho
    dados = [];

    // Detectar o número de colunas e dinamicamente identificar as relevantes
    linhas.forEach((linha) => {
        const valores = linha.split(",");
        
        const numeroConcurso = Number(valores[0]);  // Coluna 1: Número do concurso
        const dataSorteio = new Date(valores[1].split("/").reverse().join("-")).getTime();  // Coluna 2: Data do sorteio (transforma em timestamp)
        const bolas = valores.slice(2, 17).map(Number);  // Colunas de bolas sorteadas

        if (bolas.length === 15 && bolas.every(num => !isNaN(num))) {
            // Adicionar o número do concurso e a data como parte dos dados
            dados.push({ numeroConcurso, dataSorteio, bolas });
        }
    });

    if (dados.length === 0) {
        alert("Nenhum dado válido encontrado!");
    }
}

    // Detectar o número de colunas e dinamicamente identificar as relevantes
    linhas.forEach((linha) => {
        const valores = linha.split(",");
        
        const numeroConcurso = Number(valores[0]);  // Coluna 1: Número do concurso
        const dataSorteio = new Date(valores[1].split("/").reverse().join("-")).getTime();  // Coluna 2: Data do sorteio (transforma em timestamp)
        const bolas = valores.slice(2, 17).map(Number);  // Colunas de bolas sorteadas

        if (bolas.length === 15 && bolas.every(num => !isNaN(num))) {
            // Adicionar o número do concurso e a data como parte dos dados
            dados.push({ numeroConcurso, dataSorteio, bolas });
        }
    });

    if (dados.length === 0) {
        alert("Nenhum dado válido encontrado!");
    }
}


        // Função para criar o modelo do Sherlock
    async function criarModelo() {
            if (!model) {
                model = tf.sequential();
                model.add(tf.layers.dense({ units: 128, activation: 'relu', inputShape: [15] }));
                model.add(tf.layers.dense({ units: 128, activation: 'relu' }));
                model.add(tf.layers.dense({ units: 15, activation: 'sigmoid' }));
                model.compile({ optimizer: 'adam', loss: 'meanSquaredError' });
            }
        }

        async function treinarModelo() {
    if (dados.length === 0) {
      alert("Carregue os dados primeiro!");
      return;
    }
    if (treinando) {
      alert("O modelo já está sendo treinado.");
      return;
    }
    treinando = true;

    const numeroDeBolas = dados[0].bolas.length;
    if (!model) {
      model = tf.sequential();

      // Entrada combinada de bolas, número do concurso e data
      model.add(tf.layers.dense({ units: 128, activation: 'relu', inputShape: [numeroDeBolas + 2] })); // +2 para número de concurso e data
      model.add(tf.layers.dense({ units: 128, activation: 'relu' }));
      model.add(tf.layers.dense({ units: 64, activation: 'relu' }));  // Primeira camada adicional
      model.add(tf.layers.dense({ units: 32, activation: 'relu' }));  // Segunda camada adicional
      model.add(tf.layers.dense({ units: 16, activation: 'relu' }));  // Terceira camada adicional
      model.add(tf.layers.dense({ units: numeroDeBolas, activation: 'sigmoid' }));  // Saída com o número de bolas
      model.compile({ optimizer: 'adam', loss: 'meanSquaredError' });
    }

    // Normalizar os números de concursos e datas (entre 0 e 1)
    const maxConcurso = Math.max(...dados.map(d => d.numeroConcurso));
    const minData = Math.min(...dados.map(d => d.dataSorteio));
    const maxData = Math.max(...dados.map(d => d.dataSorteio));

    const xs = tf.tensor2d(dados.map(d => [
      ...d.bolas.map(bola => bola / 25), 
      d.numeroConcurso / maxConcurso, 
      (d.dataSorteio - minData) / (maxData - minData)
    ]));

    const ys = tf.tensor2d(dados.map(d => d.bolas.map(bola => bola / 25)));  // Saída com as bolas sorteadas

    // Gráficos para visualizar o progresso
    const surface = { name: 'Gráficos de Treinamento', tab: 'Treinamento' };
    const lossValues = [];

    // Treinamento com 10% de controle
    const numEpocas = 100;
    const controlePercentual = 0.1;
    const epocasTreinamento = Math.floor(numEpocas * (1 - controlePercentual));  // 90% para treinamento normal
    const epocasControle = numEpocas - epocasTreinamento;  // 10% para controle

    // Função para adicionar ruído aos dados (controle)
    function adicionarRuido(tensor) {
      return tensor.add(tf.randomNormal(tensor.shape, 0, 0.1));  // Adiciona ruído com desvio padrão 0.1
    }

    // Treinamento normal (90%)
    await model.fit(xs, ys, {
      epochs: epocasTreinamento,
      callbacks: {
        onEpochEnd: (epoch, logs) => {
          const progresso = Math.floor(((epoch + 1) / numEpocas) * 100);
          document.getElementById('progressBar').style.width = progresso + '%';
          document.getElementById('progressBar').innerText = progresso + '%';
          document.getElementById('statusTreinamento').innerText = `Época ${epoch + 1} concluída. Erro: ${logs.loss.toFixed(6)}`;

          // Armazenar perda (loss) e renderizar o gráfico
          lossValues.push({ epoch: epoch + 1, loss: logs.loss });
          tfvis.render.linechart(surface, { values: lossValues, series: ['Loss'] }, {
            xLabel: 'Epoch',
            yLabel: 'Loss',
            width: 400,
            height: 300
          });
        }
      }
    });

    // Treinamento de controle (10%) - adiciona ruído
    const xsControle = adicionarRuido(xs);
    await model.fit(xsControle, ys, {
      epochs: epocasControle,
      callbacks: {
        onEpochEnd: (epoch, logs) => {
          const progresso = Math.floor(((epoch + 1 + epocasTreinamento) / numEpocas) * 100);
          document.getElementById('progressBar').style.width = progresso + '%';
          document.getElementById('progressBar').innerText = progresso + '%';
          document.getElementById('statusTreinamento').innerText = `Época ${epoch + 1 + epocasTreinamento} concluída. Erro: ${logs.loss.toFixed(6)}`;

          lossValues.push({ epoch: epoch + 1 + epocasTreinamento, loss: logs.loss });
          tfvis.render.linechart(surface, { values: lossValues, series: ['Loss'] }, {
            xLabel: 'Epoch',
            yLabel: 'Loss',
            width: 400,
            height: 300
          });
        }
      }
    });

    treinando = false;
    alert("Treinamento concluído!");
}


        // Função para carregar o modelo salvo
        async function carregarModelo() {
            const jsonUpload = document.getElementById('modelJson').files[0];
            const weightsUpload = document.getElementById('modelWeights').files[0];

            if (jsonUpload && weightsUpload) {
                model = await tf.loadLayersModel(tf.io.browserFiles([jsonUpload, weightsUpload]));
                alert("Modelo carregado com sucesso!");
            } else {
                alert("Por favor, carregue ambos os arquivos .json e .bin!");
            }
        }

        // Função para jogar com o modelo carregado
    function jogarComModelo() {
            if (!model) {
                alert("Por favor, carregue o modelo antes de jogar!");
                return;
            }
            alert("Jogando com o modelo carregado...");
            gerarPalpites();
    }


    // Função para gerar palpites do Sherlock
    function gerarPalpites() {
    palpites = [];
    const penultimoConcurso = dados[dados.length - 2].bolas;

        for (let i = 0; i < numCiclos; i++) {
            const input = tf.tensor2d([penultimoConcurso.map(bola => bola / 25)]);
            const predicao = model.predict(input).dataSync();
            const bolasPrevistas = Array.from(predicao).map(p => Math.round(p * 25)).slice(0, 15);
            palpites.push(bolasPrevistas);
        }
    }

    // Função para iniciar ciclo de previsões
    async function iniciarCiclo() {
        if (cicloRodando) {
            alert("Ciclo já está rodando.");
            return;
        }
        cicloRodando = true;
        document.getElementById('progressBarCiclo').style.width = '0%';
        document.getElementById('progressBarCiclo').innerText = '0%';
        document.getElementById('statusCiclo').innerText = 'Ciclo iniciado. Gerando palpites...';

        gerarPalpites();

        for (let cicloAtual = 0; cicloAtual < numCiclos; cicloAtual++) {
            const progressoCiclo = Math.floor((cicloAtual / numCiclos) * 100);
            document.getElementById('progressBarCiclo').style.width = progressoCiclo + '%';
            document.getElementById('progressBarCiclo').innerText = progressoCiclo + '%';
            document.getElementById('statusCiclo').innerText = `Ciclo ${cicloAtual + 1} concluído`;

            await new Promise(resolve => setTimeout(resolve, 500)); // Pausa para não travar o navegador
        }

        atualizarPlacar();
        cicloRodando = false;
        document.getElementById('statusCiclo').innerText = "Ciclo de previsões concluído!";
    }

    // Função para atualizar o placar das gerações
    function atualizarPlacar() {
        const ul = document.getElementById("geracoesRanking");
        ul.innerHTML = '';
        campeoes.forEach(campeao => {
            const li = document.createElement("li");
            li.innerText = `Geração ${campeao.geracao}: ${campeao.pontos} pontos`;
            ul.appendChild(li);
        });
    }

    // Função para aplicar a lógica de recompensa e punição
function aplicarRecompensaEPunicao(palpite, acertos) {
    let pontos = 0;

    // Recompensa por acertos
    if (acertos === 13) {
        pontos += 50; // Exemplo de pontuação para 13 acertos
    } else if (acertos === 14) {
        pontos += 100; // Exemplo de pontuação para 14 acertos
    } else if (acertos === 15) {
        pontos += 200; // Exemplo de pontuação para 15 acertos
    }

    // Punição por baixo desempenho
    if (acertos < 13) {
        pontos -= 20; // Punição por menos de 13 acertos
    }

    return pontos;
}

    // Função para verificar acertos do Sherlock
    function verificarAcertos(palpite) {
        const concursoAtual = dados[dados.length - 1].bolas;
        const acertos = palpite.filter(num => concursoAtual.includes(num)).length;
        return acertos;
    }

    // Função para realizar a competição entre gerações
    function competicaoEntreGeracoes() {
        let maxPontos = -Infinity;
        let campeao = null;

    // Gerações de Sherlock jogam e comparam resultados
    for (let geracao = 1; geracao <= geracaoAtual; geracao++) {
        let pontos = 0;
        for (let i = 0; i < palpites.length; i++) {
            const acertos = verificarAcertos(palpites[i]);
            pontos += aplicarRecompensaEPunicao(palpites[i], acertos);
        }

        // Verifica quem é o campeão da geração
        if (pontos > maxPontos) {
            maxPontos = pontos;
            campeao = { geracao, pontos };
        }

        // Armazenar resultado da geração atual
        campeoes.push(campeao);
    }

    atualizarPlacar();
    }


    // Função para exibir os resultados dos palpites
function exibirResultados(palpites) {
    const resultadosDiv = document.getElementById('resultadosCiclo');
    
    if (!resultadosDiv) {
        console.error("Elemento 'resultadosCiclo' não encontrado!");
        return;
    }

    // Limpa os resultados anteriores
    resultadosDiv.innerHTML = '';

    // Exibe os palpites gerados
    palpites.forEach((palpite, index) => {
        const palpiteText = `Palpite ${index + 1}: ${palpite.join(", ")}`;
        const pElement = document.createElement('p');
        pElement.innerText = palpiteText;
        resultadosDiv.appendChild(pElement);
    });
    }

    // Função para salvar o modelo treinado
    async function salvarModelo() {
        const saveResult = await model.save('downloads://modelo-sherlock');
        console.log("Modelo salvo com sucesso:", saveResult);
    }
</script>

</body>
</html>